"""
MPQ archive validator for WoW WotLK 3.3.5a.

Validates:
- All expected files are present in the archive/directory
- Internal paths match WoW conventions
- Checks for orphaned files
- Listfile presence
"""

import os

from ..qa_validator import ValidationResult, ValidationSeverity


# ---------------------------------------------------------------------------
# Constants
# ---------------------------------------------------------------------------

# Expected WoW path prefixes
_WOW_MAP_PREFIX = "World" + os.sep + "Maps"
_WOW_DBC_PREFIX = "DBFilesClient"

# Common WoW file extensions
_EXPECTED_EXTENSIONS = {'.wdt', '.adt', '.dbc', '.blp', '.wmo', '.m2', '.skin'}


# ---------------------------------------------------------------------------
# File discovery
# ---------------------------------------------------------------------------

def _find_mpq_content(client_dir):
    """
    Find the MPQ content root directory.

    The mpq_packer writes files to {output}/mpq_content/World/Maps/...
    We also check client_dir directly in case it IS the content root.
    """
    if not client_dir or not os.path.isdir(client_dir):
        return None

    # Check for mpq_content subdirectory (generated by mpq_packer)
    mpq_content = os.path.join(client_dir, "mpq_content")
    if os.path.isdir(mpq_content):
        return mpq_content

    # Check if client_dir itself contains World/Maps/
    if os.path.isdir(os.path.join(client_dir, "World")):
        return client_dir

    return None


def _collect_files(content_root):
    """
    Collect all files under content_root with relative paths.

    Returns list of relative path strings using OS separators.
    """
    files = []
    for root, _dirs, filenames in os.walk(content_root):
        for fname in filenames:
            full_path = os.path.join(root, fname)
            rel_path = os.path.relpath(full_path, content_root)
            files.append(rel_path)
    return files


def _find_map_dirs(content_root):
    """Find map directories under World/Maps/."""
    maps_root = os.path.join(content_root, "World", "Maps")
    if not os.path.isdir(maps_root):
        return []
    return [d for d in os.listdir(maps_root)
            if os.path.isdir(os.path.join(maps_root, d))]


# ---------------------------------------------------------------------------
# Validation
# ---------------------------------------------------------------------------

def validate_mpq_files(client_dir):
    """
    Validate MPQ archive contents (or directory structure).

    Returns:
        List of ValidationResult objects.
    """
    results = []

    content_root = _find_mpq_content(client_dir)

    if content_root is None:
        results.append(ValidationResult(
            check_id='MPQ-001',
            severity=ValidationSeverity.INFO,
            passed=True,
            message="No MPQ content directory found to validate",
        ))
        return results

    all_files = _collect_files(content_root)

    if not all_files:
        results.append(ValidationResult(
            check_id='MPQ-001',
            severity=ValidationSeverity.ERROR,
            passed=False,
            message="MPQ content directory is empty",
            fix_suggestion="Check mpq_packer.py add_file calls",
        ))
        return results

    # MPQ-001: All expected files present
    # For each map directory, expect a .wdt and at least one .adt
    map_names = _find_map_dirs(content_root)
    missing_files = []

    for map_name in map_names:
        maps_root = os.path.join(content_root, "World", "Maps")
        map_dir = os.path.join(maps_root, map_name)

        # Check for WDT
        wdt_name = "{}.wdt".format(map_name)
        wdt_path = os.path.join(map_dir, wdt_name)
        if not os.path.isfile(wdt_path):
            missing_files.append("World/Maps/{}/{}".format(
                map_name, wdt_name))

        # Check that at least one ADT exists
        has_adt = any(f.lower().endswith('.adt')
                      for f in os.listdir(map_dir)
                      if os.path.isfile(os.path.join(map_dir, f)))
        if not has_adt:
            missing_files.append("World/Maps/{}/[any .adt file]".format(
                map_name))

    if not missing_files:
        results.append(ValidationResult(
            check_id='MPQ-001',
            severity=ValidationSeverity.ERROR,
            passed=True,
            message="All expected files present ({} files, {} maps)".format(
                len(all_files), len(map_names)),
        ))
    else:
        results.append(ValidationResult(
            check_id='MPQ-001',
            severity=ValidationSeverity.ERROR,
            passed=False,
            message="Missing expected files: {}".format(
                missing_files[:5]),
            fix_suggestion="Check mpq_packer.py add_file calls",
        ))

    # MPQ-002: Internal paths match WoW conventions
    bad_paths = []
    for rel_path in all_files:
        # Normalize to forward slashes for checking
        normalized = rel_path.replace(os.sep, "/")

        # Should start with World/ or DBFilesClient/
        valid_prefix = (
            normalized.startswith("World/")
            or normalized.startswith("DBFilesClient/")
            or normalized.startswith("Interface/")
            or normalized.lower() == "(listfile)"
        )
        if not valid_prefix:
            bad_paths.append(normalized)

    if not bad_paths:
        results.append(ValidationResult(
            check_id='MPQ-002',
            severity=ValidationSeverity.WARNING,
            passed=True,
            message="All file paths match WoW conventions",
        ))
    else:
        results.append(ValidationResult(
            check_id='MPQ-002',
            severity=ValidationSeverity.WARNING,
            passed=False,
            message="{} files with non-standard paths: {}".format(
                len(bad_paths), bad_paths[:3]),
            fix_suggestion="Fix path strings in packer",
        ))

    # MPQ-003: Orphaned files (files not part of any known map)
    known_map_prefixes = set()
    for map_name in map_names:
        known_map_prefixes.add(
            "World" + os.sep + "Maps" + os.sep + map_name)

    orphaned = []
    for rel_path in all_files:
        ext = os.path.splitext(rel_path)[1].lower()
        if ext not in _EXPECTED_EXTENSIONS:
            continue

        # Check if file belongs to a known map or DBFilesClient
        is_known = False
        for prefix in known_map_prefixes:
            if rel_path.startswith(prefix):
                is_known = True
                break
        if rel_path.startswith(_WOW_DBC_PREFIX):
            is_known = True
        if rel_path.startswith("Interface"):
            is_known = True

        if not is_known:
            orphaned.append(rel_path)

    if not orphaned:
        results.append(ValidationResult(
            check_id='MPQ-003',
            severity=ValidationSeverity.WARNING,
            passed=True,
            message="No orphaned files detected",
        ))
    else:
        results.append(ValidationResult(
            check_id='MPQ-003',
            severity=ValidationSeverity.WARNING,
            passed=False,
            message="{} orphaned files: {}".format(
                len(orphaned), orphaned[:3]),
            fix_suggestion="Remove unused files",
        ))

    # MPQ-004: Listfile presence
    has_listfile = any(f.lower() == "(listfile)" for f in all_files)
    if has_listfile:
        results.append(ValidationResult(
            check_id='MPQ-004',
            severity=ValidationSeverity.INFO,
            passed=True,
            message="Listfile present in archive",
        ))
    else:
        results.append(ValidationResult(
            check_id='MPQ-004',
            severity=ValidationSeverity.INFO,
            passed=False,
            message="No listfile found (optional but recommended)",
            fix_suggestion="Generate listfile for archive",
        ))

    return results
