{% from "macros/target_selection.lua.jinja2" import target_selection_helpers %}
{% from "macros/achievements.lua.jinja2" import achievement_variables, achievement_reset, achievement_check_on_death %}
-- Boss: {{ boss.name }}
-- AUTO-GENERATED by world_builder.script_generator
-- Entry: {{ boss.entry }}
-- COMPLETE AND DEPLOYABLE - NO MANUAL CHANGES REQUIRED

local Boss = {}

-- ========================================
-- SPELL CONSTANTS
-- ========================================
{% set seen_spells = [] %}
{% for phase in boss.phases %}
{% for ability in phase.abilities %}
{% if ability.spell not in seen_spells %}
{% if seen_spells.append(ability.spell) %}{% endif %}
{% if ability.spell_id >= 90000 %}
local {{ ability.spell }} = {{ ability.spell_id }}{{ "  -- Custom spell" }}
{% else %}
local {{ ability.spell }} = {{ ability.spell_id }}{{ "  -- Existing spell (reused)" }}
{% endif %}
{% endif %}
{% endfor %}
{% endfor %}
{# Include additional spell IDs referenced in void_zone damage spells #}
{% for phase in boss.phases %}
{% for ability in phase.abilities %}
{% if ability.void_zone is defined and ability.void_zone %}
{% if ability.void_zone.damage_spell != ability.void_zone.visual_spell %}
{% set dmg_name = "SPELL_" + ability.id | upper + "_DAMAGE" %}
local {{ dmg_name }} = {{ ability.void_zone.damage_spell }}  -- Custom spell (damage aura)
{% endif %}
{% endif %}
{% endfor %}
{% endfor %}

-- ========================================
-- PHASE CONSTANTS
-- ========================================
{% for phase in boss.phases %}
local {{ phase.const_name }} = {{ phase.phase_id }}
{% endfor %}

-- ========================================
-- NPC CONSTANTS
-- ========================================
{% for npc in boss.npcs %}
local {{ npc.name }} = {{ npc.entry }}  -- {{ npc.label }}
{% endfor %}

{{ achievement_variables(boss) }}

-- ========================================
-- COMBAT EVENTS
-- ========================================
function Boss.OnEnterCombat(event, creature, target)
{{ achievement_reset(boss) }}

    -- Set initial phase
    creature:SetData("PHASE", {{ boss.phases[0].phase_id }})
{% if boss.phases[0].on_enter is defined and boss.phases[0].on_enter %}
{% if boss.phases[0].on_enter.yell is defined %}

    -- Phase 1 yell
    creature:SendUnitYell("{{ boss.phases[0].on_enter.yell }}", 0)
{% endif %}
{% if boss.phases[0].on_enter.sound_id is defined %}
    creature:PlayDirectSound({{ boss.phases[0].on_enter.sound_id }})
{% endif %}
{% endif %}

    -- Start Phase 1 ability timers
{% for ability in boss.phases[0].abilities %}
    creature:RegisterEvent(Boss.{{ ability.func_name }}, {{ ability.timer.initial }}, 0)
{% endfor %}
{% if boss.phases | length > 1 %}

    -- Start phase check timer (every 1 second)
    creature:RegisterEvent(Boss.CheckPhaseTransition, 1000, 0)
{% endif %}
end

function Boss.OnLeaveCombat(event, creature)
    -- Clean up all timers
    creature:RemoveEvents()

    -- Reset phase
    creature:SetData("PHASE", 0)

{{ achievement_reset(boss) }}

    -- Despawn any summoned adds
{% for npc in boss.npcs %}
    local cleanup_{{ loop.index }} = creature:GetCreaturesInRange(100, {{ npc.entry }})
    for _, add in pairs(cleanup_{{ loop.index }}) do
        if add:IsAlive() then
            add:DespawnOrUnsummon(0)
        end
    end
{% endfor %}
end

function Boss.OnDied(event, creature, killer)
    -- Clean up all timers
    creature:RemoveEvents()

{% if boss.on_death.yell is defined %}
    -- Death yell
    creature:SendUnitYell("{{ boss.on_death.yell }}", 0)
{% endif %}
{% if boss.on_death.sound_id is defined %}
    creature:PlayDirectSound({{ boss.on_death.sound_id }})
{% endif %}

{{ achievement_check_on_death(boss) }}

    -- Notify instance script
    local instance = creature:GetInstanceData()
    if instance then
        -- Update encounter state (Boss {{ boss.encounter_id }} = {{ boss.name }})
        local encounter_id = {{ boss.encounter_id }}
        local state = instance:GetData("ENCOUNTER_STATE") or 0
        state = bit.bor(state, bit.lshift(1, encounter_id))
        instance:SetData("ENCOUNTER_STATE", state)

{% if boss.on_death.unlock_door is defined and boss.on_death.unlock_door %}
        -- Unlock door
        local door = instance:GetGameObject({{ boss.on_death.unlock_door }})
        if door then
            door:SetGoState(1)  -- Open
        end

{% endif %}
        -- Save instance data
        instance:SaveInstanceData()
    end

    -- Despawn remaining adds
{% for npc in boss.npcs %}
    local death_cleanup_{{ loop.index }} = creature:GetCreaturesInRange(100, {{ npc.entry }})
    for _, add in pairs(death_cleanup_{{ loop.index }}) do
        if add:IsAlive() then
            add:DespawnOrUnsummon(0)
        end
    end
{% endfor %}
end

{% if boss.phases | length > 1 %}
-- ========================================
-- PHASE TRANSITIONS
-- ========================================
function Boss.CheckPhaseTransition(event, delay, repeats, creature)
    local hp_pct = creature:GetHealthPct()
    local current_phase = creature:GetData("PHASE")

{% for phase in boss.phases %}
{% if not loop.first %}
{% set prev_phase = boss.phases[loop.index0 - 1] %}
    -- Phase {{ phase.phase_id }} transition at {{ phase.hp_range[0] }}% HP
    if hp_pct <= {{ phase.hp_range[0] }} and current_phase == {{ prev_phase.phase_id }} then
        creature:SetData("PHASE", {{ phase.phase_id }})

{% if phase.on_enter is defined and phase.on_enter %}
{% if phase.on_enter.yell is defined %}
        -- Phase transition yell
        creature:SendUnitYell("{{ phase.on_enter.yell }}", 0)
{% endif %}
{% if phase.on_enter.sound_id is defined %}
        creature:PlayDirectSound({{ phase.on_enter.sound_id }})
{% endif %}
{% endif %}

        -- Remove all previous phase timers
        creature:RemoveEvents()

{% if phase.on_enter is defined and phase.on_enter and phase.on_enter.action is defined and phase.on_enter.action %}
{% if phase.on_enter.action.type == 'transform_adds' %}
        -- Transform adds: {{ phase.on_enter.action.from_entry }} -> {{ phase.on_enter.action.to_entry }}
        local old_adds = creature:GetCreaturesInRange(100, {{ phase.on_enter.action.from_entry }})
        for _, add in pairs(old_adds) do
            if add:IsAlive() then
                local ax, ay, az, ao = add:GetLocation()
                add:DespawnOrUnsummon(0)
                creature:SummonCreature({{ phase.on_enter.action.to_entry }}, ax, ay, az, ao, 1, 0)
            end
        end

{% elif phase.on_enter.action.type == 'despawn_all_adds' %}
        -- Despawn all adds
{% for npc in boss.npcs %}
        local trans_cleanup_{{ loop.index }} = creature:GetCreaturesInRange(100, {{ npc.entry }})
        for _, add in pairs(trans_cleanup_{{ loop.index }}) do
            if add:IsAlive() then
                add:DespawnOrUnsummon(0)
            end
        end
{% endfor %}

{% elif phase.on_enter.action.type == 'apply_buff' %}
        -- Apply buff
        creature:CastSpell(creature, {{ phase.on_enter.action.buff_spell }}, false)

{% endif %}
{% endif %}
        -- Start Phase {{ phase.phase_id }} ability timers
{% for ability in phase.abilities %}
        creature:RegisterEvent(Boss.{{ ability.func_name }}, {{ ability.timer.initial }}, 0)
{% endfor %}

        -- Re-register phase check timer
        creature:RegisterEvent(Boss.CheckPhaseTransition, 1000, 0)
        return
    end

{% endif %}
{% endfor %}
end

{% endif %}
-- ========================================
-- ABILITY FUNCTIONS
-- ========================================

{% for phase in boss.phases %}
-- ----------------------------------------
-- {{ phase.name }}
-- ----------------------------------------

{% for ability in phase.abilities %}
{% if ability.summon is defined and ability.summon %}
-- {{ ability.name }} ({{ ability.description }})
function Boss.{{ ability.func_name }}(event, delay, repeats, creature)
    local current_phase = creature:GetData("PHASE")

    -- Only in Phase {{ phase.phase_id }}
    if current_phase ~= {{ phase.phase_id }} then
        return
    end

{% if ability.summon.position == 'random_around_boss' %}
    -- Summon {{ ability.summon.count }} adds at random positions around boss
    for i = 1, {{ ability.summon.count }} do
        local angle = math.random() * 2 * math.pi
        local x, y, z, o = creature:GetLocation()
        local spawn_x = x + {{ ability.summon.radius }} * math.cos(angle)
        local spawn_y = y + {{ ability.summon.radius }} * math.sin(angle)

        local add = creature:SummonCreature({{ ability.summon.entry }}, spawn_x, spawn_y, z, o, 1, {{ ability.summon.duration }})
        if add then
            -- Attack a random player
            local target = Boss.GetRandomPlayer(creature)
            if target then
                add:Attack(target)
            end
        end
    end
{% elif ability.summon.position == 'fixed_spawn_points' %}
    -- Summon adds at fixed spawn points
    local spawn_points = {
{% for point in ability.summon.spawn_points %}
        {x = {{ point.x }}, y = {{ point.y }}, z = {{ point.z }}},
{% endfor %}
    }
    for _, point in ipairs(spawn_points) do
        local add = creature:SummonCreature({{ ability.summon.entry }}, point.x, point.y, point.z, 0, 1, {{ ability.summon.duration }})
        if add then
            local target = Boss.GetRandomPlayer(creature)
            if target then
                add:Attack(target)
            end
        end
    end
{% endif %}

    -- Reschedule
{% if ability.timer.min == ability.timer.max %}
    creature:RegisterEvent(Boss.{{ ability.func_name }}, {{ ability.timer.min }}, 0)
{% else %}
    local next_cast = math.random({{ ability.timer.min }}, {{ ability.timer.max }})
    creature:RegisterEvent(Boss.{{ ability.func_name }}, next_cast, 0)
{% endif %}
end

{% elif ability.void_zone is defined and ability.void_zone %}
-- {{ ability.name }} ({{ ability.description }})
function Boss.{{ ability.func_name }}(event, delay, repeats, creature)
    local current_phase = creature:GetData("PHASE")

    -- Only in Phase {{ phase.phase_id }}
    if current_phase ~= {{ phase.phase_id }} then
        return
    end

    -- Target random player for void zone placement
    local target = Boss.GetRandomPlayer(creature)
    if target then
        -- Cast visual spell at target location
        creature:CastSpell(target, {{ ability.void_zone.visual_spell }}, false)
    end

    -- Reschedule
{% if ability.timer.min == ability.timer.max %}
    creature:RegisterEvent(Boss.{{ ability.func_name }}, {{ ability.timer.min }}, 0)
{% else %}
    local next_cast = math.random({{ ability.timer.min }}, {{ ability.timer.max }})
    creature:RegisterEvent(Boss.{{ ability.func_name }}, next_cast, 0)
{% endif %}
end

{% elif ability.turret is defined and ability.turret %}
-- {{ ability.name }} ({{ ability.description }})
function Boss.{{ ability.func_name }}(event, delay, repeats, creature)
    local current_phase = creature:GetData("PHASE")

    -- Only in Phase {{ phase.phase_id }}
    if current_phase ~= {{ phase.phase_id }} then
        return
    end

    -- Activate {{ ability.turret.count }} turret(s)
    local turrets = creature:GetCreaturesInRange(100, {{ ability.turret.entries[0] }})
    local activated = 0
    for _, turret in pairs(turrets) do
        if activated < {{ ability.turret.count }} then
            turret:SetData("ACTIVE", 1)
            -- Turret will auto-deactivate after duration
            turret:RegisterEvent(function(ev, d, r, t)
                t:SetData("ACTIVE", 0)
                t:RemoveEvents()
            end, {{ ability.turret.duration }}, 1)
            activated = activated + 1
        end
    end

    -- Reschedule
{% if ability.timer.min == ability.timer.max %}
    creature:RegisterEvent(Boss.{{ ability.func_name }}, {{ ability.timer.min }}, 0)
{% else %}
    local next_cast = math.random({{ ability.timer.min }}, {{ ability.timer.max }})
    creature:RegisterEvent(Boss.{{ ability.func_name }}, next_cast, 0)
{% endif %}
end

{% else %}
-- {{ ability.name }} ({{ ability.description }})
function Boss.{{ ability.func_name }}(event, delay, repeats, creature)
    local current_phase = creature:GetData("PHASE")

    -- Only in Phase {{ phase.phase_id }}
    if current_phase ~= {{ phase.phase_id }} then
        return
    end

{% if ability.cast_time is defined and ability.cast_time %}
    -- Don't cast if already casting
    if creature:IsCasting() then
        return
    end

{% endif %}
{% if ability.targeting.type == 'current' %}
    -- Target current victim (tank)
    local target = creature:GetVictim()
{% elif ability.targeting.type == 'random_player' %}
    -- Target random player
    local target = Boss.GetRandomPlayer(creature)
{% elif ability.targeting.type == 'aoe' or ability.targeting.type == 'self' %}
    -- Target self (AoE effect)
    local target = creature
{% endif %}

    if target then
        creature:CastSpell(target, {{ ability.spell_id }}, false)
    end

    -- Reschedule
{% if ability.timer.min == ability.timer.max %}
    creature:RegisterEvent(Boss.{{ ability.func_name }}, {{ ability.timer.min }}, 0)
{% else %}
    local next_cast = math.random({{ ability.timer.min }}, {{ ability.timer.max }})
    creature:RegisterEvent(Boss.{{ ability.func_name }}, next_cast, 0)
{% endif %}
end

{% endif %}
{% endfor %}
{% endfor %}
{{ target_selection_helpers() }}

-- ========================================
-- EVENT REGISTRATION
-- ========================================
RegisterCreatureEvent({{ boss.entry }}, 1, Boss.OnEnterCombat)    -- CREATURE_EVENT_ON_ENTER_COMBAT
RegisterCreatureEvent({{ boss.entry }}, 2, Boss.OnLeaveCombat)    -- CREATURE_EVENT_ON_LEAVE_COMBAT
RegisterCreatureEvent({{ boss.entry }}, 4, Boss.OnDied)           -- CREATURE_EVENT_ON_DIED
